<style>
    main {
        height:2500px;
        background-color: white;
        color: black;
        margin-left: 1.2em;

        line-height: 25px;
        
    }
    

@import url(https://fonts.googleapis.com/css?family=Montserrat);
@import url(https://fonts.googleapis.com/css?family=Open+Sans);

main {
    font-family: 'Montserrat';
}

/*Classes*/

@media(min-width: 801px) {

    .ds-sect, .pg-img {
        padding-top: 30px;
        padding-left: 30px;
        font-size: 22px;
    }

    .ds-sect:last-child {
        padding-bottom: 20px;
    }

    .ds-sect code {
        margin-right: 200px;
        
        font-size: 18px;
        color: green;
    }


}

@media(max-width: 800px) {
    main {
        background-color: white;
    }

    .ds-sect {
        font-size: 5vw;
        
        padding: 20px 0px 20px 10px;
    }
   
    .pg-img {
        width: 100%;
        height: auto;
    }

    .ds-sect code {
        color: green;
        font-family: monospace;
        font-size: 12px;
        padding-left: 10px;
        line-height: 20px;
    }

    
}

</style>
<!DOCTYPE html>
<html>
<head>
    <script src="https://code.jquery.com/jquery-3.4.1.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
    <script src="my-js/core.js"></script>

</head>
<body>
    <header id="header"></header>

    <main>
        <div class="ds-sect">
            <h1>Hash Tables</h1>
        </div>
        <div class="ds-sect title"><h2>What are they?</h2></div>
        <div class="ds-sect definition">
                <p>A hash table is a data structure that can map a key to a value in 
                an array-like structure, using a hash function.<br>It is highly 
                efficient for adding, removing, and retrieving data because of its
                key-value pair system.
                </p>
            <img class= "pg-img"  src = "images/hash-table-demo.jpg" alt = "hash table demo img">
        </div>

        <div class="ds-sect title"><h2>Hashing Function</h2></div>
        <div class="ds-sect">
            <p>The job of the hash function is to generate a unique index
            with a provided key, and the value will be stored at this index.<br>
            It is important that the function creates a <b>hash code</b> that is 
            usually unique- this minimizes collisions which can slow down the 
            operations of the table.<br>The hash code is then compressed to fit into the range
            of indices of the table. 
            </p>
        </div>

        <div class="ds-sect title"><h2>Hash Collisions</h2></div>
        <div class = "ds-sect list">
            <h3>What are they?</h3>
                <p>Hash collisions occur when two distinct keys are mapped to the same spot in the 
                hash table. <br>This happens when the generated hash codes are compressed.
                </p>
            <h3>How are they handled?</h3>
                <p>Hash collisions can be handled using two different approaches:<br>
                <i>open addressing</i> and <i>separate chaining</i>.</p>
        </div>

        <div class="ds-sect title"><h3>Open Addressing</h3></div>
        <div class="ds-sect performance">
            <p>When a value is being mapped to an index that already exists, we can
                check if any nearby indices are empty so we can place it there instead.<br>
                Checking for empty spots in increments of one is known as <b>linear probing</b>
                and squaring the increments (k+1, k+4, k+9, etc) is <b>quadratic probing</b>.
            </p>
            <img  class= "pg-img" src = "images/linear-probing.jpg" alt = "linear-probing img">
            <h4>Issues with probing</h4>
                <p>One issue with using probing is that it can lead to <b>clustering</b>.
                This is when a particular range of the table is cluttered with many <br>
                taken spots. This can cause future probing to take much longer, since
                a longer traversal is made each time to keep finding an empty spot.</p>
                <img  class= "pg-img" src = "images/clustered-img.jpg" alt = "img of clustered table">
        </div>

        <div class="ds-sect title">
            <h3>Separate chaining</h3>
        </div>
        <div class="ds-sect">
            <p>Here, we scrap the idea of checking for nearby empty spots. Instead, we treat
                each index as a bucket that can store multiple different values.<br>The bucket
                can be any data structure that such as a linked list or sorted tree. When
                a value is being mapped to an index, it is added to the index's bucket.<br>
                Using a linked list example, this would meaning adding another node to the linked
                list containing the new value.
            </p>
            <img  class= "pg-img" src = "images/seperate-chaining.jpg" alt = "separate chaining img">
        </div>


        <div class="ds-sect">
            <h2>Performance</h2>
        </div>
        <div class="ds-sect performance">
            <p>Hashtables can perform insertion, deletion, and searching at O(1) time, 
                making them an optimal solution for many problems in computer science.<br>
                
                They have the advantage of easy access anywhere just like with arrays, but on top of that,
                its contents are quickly found if one knows the key.
            </p>
        </div>
    </main>

    <footer id="footer"></footer>

</body>
</html>